/* ********************** Utils.c ***********************************
    Title:    		Utils.c
	Project:		L2CV300TDD
    Author:   		Alexopoulos Ilias
    Company:		Intralot S.A.
    Date:     		09 ��� 2012
    Purpose:
    Configuration: 	CodeWarrior MCF 10.2
    Last updated:
    CPU: 			PIC16F6627

    Version     Date            Description
    V0.00       09 Oct 2012    	Creation


************************************************************************* */
#include "settings.h"
#include "StdTypes.h"
#include "sysdefs.h"

#include "Utils.h"

/*
 * crc32g.c
 *
 * Code generated by universal_crc by Danjel McGougan
 *
 * CRC parameters used:
 *   bits:       32
 *   poly:       0x04c11db7
 *   init:       0x00000000
 *   xor:        0xffffffff
 *   reverse:    false
 *   non-direct: false
 *
 * CRC of the string "123456789" is 0x765e7680
 */


extern const INT32U crc_table[1024];

// CRC Internal Functions

static inline INT32U crc_init(void)
{
	return 0xffffffff;
}

static inline INT32U crc_next(INT32U crc, INT8U data)
{
#ifdef ARCH_LITTLE_ENDIAN
	return (crc >> 8) ^ crc_table[(crc & 0xff) ^ data];
#else
	return (crc << 8) ^ crc_table[((crc >> 24) & 0xff) ^ data];
#endif
}


/*
 * Process 4 bytes in one go
 * The data parameter must contain all 4 bytes;
 *   On big-endian machines: first message byte is the most significant byte
 *   On little-endian machines: first message byte is the least significant byte
 */
static inline INT32U crc_next4(INT32U crc, INT32U data)
{
#ifdef ARCH_LITTLE_ENDIAN
	crc ^= data;
	crc =
		crc_table[(crc & 0xff) + 0x300] ^
		crc_table[((crc >> 8) & 0xff) + 0x200] ^
		crc_table[((crc >> 16) & 0xff) + 0x100] ^
		crc_table[(crc >> 24) & 0xff];
#else
	crc ^= data;
	crc =
		crc_table[crc & 0xff] ^
		crc_table[((crc >> 8) & 0xff) + 0x100] ^
		crc_table[((crc >> 16) & 0xff) + 0x200] ^
		crc_table[((crc >> 24) & 0xff) + 0x300];
#endif
	return crc;
}

static inline INT32U crc_final(INT32U crc)
{
#ifndef ARCH_LITTLE_ENDIAN
	crc = (crc >> 16) | ((crc & 0xffff) << 16);
	crc = ((crc >> 8) & 0xff00ff) | ((crc & 0xff00ff) << 8);
#endif
	return ~crc;
}


// v_currcrc is not currently used internally. Left here for future expansion
INT32U f_CRCCompute(PINT8U p_base, INT32U v_length, INT32U v_currcrc)
{
	//const INT8U *data, INT32U len, INT32U v_crc)
   INT32U crc;

	crc = crc_init();

	while (((INT32U)p_base & 3) && v_length) {
		crc = crc_next(crc, *p_base++);
		v_length--;
	}

	while (v_length >= 16) {
		v_length -= 16;
		crc = crc_next4(crc, ((INT32U *)p_base)[0]);
		crc = crc_next4(crc, ((INT32U *)p_base)[1]);
		crc = crc_next4(crc, ((INT32U *)p_base)[2]);
		crc = crc_next4(crc, ((INT32U *)p_base)[3]);
		p_base += 16;
	}

	while (v_length--) {
		crc = crc_next(crc, *p_base++);
	}

	return crc_final(crc);
}


/*!
 * \brief calculates 16-bit CRC of given data, no LUT
 * \details based on the polynomial x^16+x^15+x^2+1
 * @param p_start : Pointer to start of data
 * @param p_end   : Pointer to end of data
 * @return 16-bit CRC value of block
 */
INT16U f_Util_CRC16(PINT16U p_start, PINT16U p_end)
{
	INT16U crc, c;
	INT32U i;

	crc = 0;

	while (p_start <= p_end)
	{
		c=*p_start;
		for(i=0;i<16;i++)
		{
			if((crc ^ c) & 1) crc=(crc>>1)^0xA001;
			else crc>>=1;
			c>>=1;
		}
		p_start++;
	}

	return(crc);
}




#define POLYVAL 0x8C

/*!
 * \brief Update 8-bit CRC value, no LUT
 * \details using polynomial  X^8 + X^5 + X^4 + 1 (POLYVAL)
 * @param v_new		: new data to compute CEC
 * @param v_currcrc : Current CRC value
 * @return updated CRC 8-bit value
 */

INT8U f_Util_CRC8(INT8U v_new, INT8U v_currcrc)
{
  INT8U c, i;

  c = v_currcrc;
  for (i = 0; i < 8; i++)
  {
     if ((c ^ v_new) & 1) c = (c >> 1 ) ^ POLYVAL;
     else c >>= 1;
     v_new >>= 1;
  }

  return c;

}

/* ************************************************************************************************** */

/*
 *
 * Code generated by universal_crc by Danjel McGougan
 *
 * CRC parameters used:
 *   bits:       16
 *   poly:       0x1021
 *   init:       0x0000
 *   xor:        0x0000
 *   reverse:    false
 *   non-direct: false
 *
 * CRC of the string "123456789" is 0x31c3
 */


const INT16U buf_UtilsCRCTable[256] = {
	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,
	0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,
	0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,
	0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
	0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,
	0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,
	0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,
	0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,
	0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,
	0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,
	0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,
	0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
	0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,
	0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,
	0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,
	0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,
	0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,
	0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
	0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,
	0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,
	0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
	0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
	0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,
	0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,
	0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,
	0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,
	0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,
	0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,
	0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,
	0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,
	0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,
	0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0
};

c_INLINE INT16U f_UtilsCRCInit(void)
{
	return 0;
}

c_INLINE INT16U f_UtilsCRCSingleCalc(INT16U crc, INT8U data)
{
	return (crc << 8) ^ buf_UtilsCRCTable[((crc >> 8) & 0xff) ^ data];
}

c_INLINE INT16U f_UtilsCRCFinal(INT16U crc)
{
	return crc;
}

/*!
 * \brief Compute CRC CCITT-16 on a block of data
 * @param data: Pointer to start of block
 * @param len: Length to compute CRC (how many bytes)
 * @return: CRC value
 */
INT16U f_UtilsCRCBlockCalc(const INT8U *data, INT16U len)
{
	INT16U crc;

        crc = f_UtilsCRCInit();

	if (len) do {
		crc = f_UtilsCRCSingleCalc(crc, *data++);
	} while (--len);

	return f_UtilsCRCFinal(crc);
}

/*!
 * \brief Sanity check for valid ASCII chars in a packet
 * @param p_buffer: Pointer to buffer with ASCII data
 * @param v_len: Length of data to check
 * @return: 0: for non-ASCII char found, 1: for valid ASCII string
 */
INT8U f_UtilsGeneralASCIICheckOk(PINT8U p_buffer, INT8U v_len)
{
	INT8U v_idx;
	INT8U v_data;
	INT8U v_result;

	/* default to ASCII */
	v_result = 1;

	for(v_idx=0; v_idx<v_len; v_idx++)
	{
		v_data = *(p_buffer + v_idx);
		if ( (v_data < 0x20) || (v_data > 0x7E) )
		{
			v_result = 0;
			break;
		}
	}

	return v_result;
}

/*!
 * \brief Sanity check for valid Hex ASCII chars (0-9A-F) in a packet
 * @param p_buffer: Pointer to buffer with Hex ASCII data
 * @param v_len: Length of data to check
 * @return: 0: for invalid number, 1: for valid ASCII Hex number
 */
INT8U f_UtilsHexASCIICheckOk(PINT8U p_buffer, INT8U v_len)
{
	INT8U v_idx;
	INT8U v_data;
	INT8U v_result;

	/* default to Hex ASCII */
	v_result = 1;

	for(v_idx=0; v_idx<v_len; v_idx++)
	{
		v_data = *(p_buffer + v_idx);
		if ( (v_data < '0') || (v_data > '9') )
		{
			if ( (v_data < 'A') || (v_data > 'F') )
			{
				v_result = 0;
				break;
			}
		}
	}

	return v_result;
}

/*!
 * \brief Check to see if the character the pointer points to, need to be escaped for N123 protocol
 * \details No buffer changes
 * @param p_data: Pointer to data for checking
 * @return Character to send, or Escape character (0xFD)
  * \dot
digraph L3TxEscSeq {
	L3SOP -> ESCape -> Other
	L3EOP -> ESCape -> Other
	L3ESC -> ESCape -> Other
	Other -> Normal

	{ rank = same; "L3SOP"; "L3EOP"; "L3ESC";}

}
 * \enddot
 */

INT8U f_UtilsL3ChkEscChar(PINT8U p_data)
{
	INT8U v_data;

	v_data = *(p_data);

	switch(v_data)
	{
		case c_L3SOP:
			v_data = c_L3ESC;
			break;
		case c_L3EOP:
			v_data = c_L3ESC;
			break;
		case c_L3ESC:
			v_data = c_L3ESC;
			break;
		default:;
	}

	return v_data;
}

/*!
 * \brief Computes the CCITT-16 CRC on a buffer (without modifying it)
 * \details No modification on buffer data is done
 * @param p_buffer: Pointer to buffer to check
 * @param v_len: Length of data to CRC
 * @return: CRC value after the application of N123
 */
INT16U f_UtilsL3ComputeCRC(PINT8U p_buffer, INT8U v_len)
{
	INT16U v_crc;
	INT8U v_data;

	/* initialize CRC */
	v_crc = f_UtilsCRCInit();

	/* loop all elements */
	while(v_len != 0)
	{
		v_data = f_UtilsL3ChkEscChar(p_buffer);

		if (v_data == c_L3ESC)
		{
			v_crc = f_UtilsCRCSingleCalc(v_crc, c_L3ESC);
			v_data = *(p_buffer);
			v_data &= 0x7F;
			v_crc = f_UtilsCRCSingleCalc(v_crc, v_data);
		}
		else
		{
			v_crc = f_UtilsCRCSingleCalc(v_crc, v_data);
		}

		p_buffer++;
		v_len--;

	}


	return v_crc;
}

/*!
 * \brief Copy and convert L3 buffer to final N123 L3 buffer
 * \details Derive buffer length by the L3 packet
 * @param p_srcbuffer : Source L3 buffer (without N123, with CRC)
 * @param p_dstbuffer : Destination N123 L3 buffer to transmit
 * @return Final length
 */
INT16U f_UtilsL3CopyConvert(PINT8U p_srcbuffer, PINT8U p_dstbuffer)
{
	INT16U v_length;
	INT16U v_wridx;
	INT16U v_rdidx;
	INT8U v_data;

	v_length = *(p_srcbuffer + 3 /* c_N123_IDX_ULEN */ ); /* Payload only */
	v_length += 4; /* Headers */
	v_length += 2; /* CRC */

	v_wridx = 0;
	v_rdidx = 0;

	/* put SOP */
	*(p_dstbuffer + v_wridx) = c_L3SOP;
	v_wridx++;

	/* loop all elements */
	while(v_length != 0)
	{
		v_data = f_UtilsL3ChkEscChar(p_srcbuffer + v_rdidx);

		if (v_data == c_L3ESC)
		{
			*(p_dstbuffer + v_wridx) = c_L3ESC;
			v_data = *(p_srcbuffer + v_rdidx);
			v_data &= 0x7F;
			v_wridx++;
			*(p_dstbuffer + v_wridx) = v_data;
		}
		else
		{
			*(p_dstbuffer + v_wridx) = v_data;
		}

		v_wridx++;
		v_rdidx++;
		v_length--;
	}

	/* put EOP */
	*(p_dstbuffer + v_wridx) = c_L3EOP;
	v_wridx++;

	/* just fill in two nulls - just because old L2C did */
	*(p_dstbuffer + v_wridx) = 0;
	v_wridx++;
	*(p_dstbuffer + v_wridx) = 0;
	v_wridx++;

	v_length = v_wridx;

	return v_length;
}

#ifdef c_UTEST_HOST
/*!
 * \brief Computes the CCITT-16 CRC on a buffer (without modifying it)
 * \details No modification on buffer data is done
 * @param p_buffer: Pointer to buffer to check
 * @param v_len: Length of data to CRC
 * @return: CRC value (assuming N123 is already applied)
 */
INT16U f_UtilsL3ComputeCRCTDD(PINT8U p_buffer, INT8U v_len)
{
	INT16U v_crc;
	INT8U v_data;

	/* initialize CRC */
	v_crc = f_UtilsCRCInit();

	/* loop all elements */
	while(v_len != 0)
	{
		/* v_data = f_UtilsL3ChkEscChar(p_buffer); */
		v_data = *(p_buffer++);
		v_crc = f_UtilsCRCSingleCalc(v_crc, v_data);
#if 0
		printf("%02X, %04X\n", v_data, v_crc);
#endif
		v_len--;

	}


	return v_crc;
}
#endif

/*!
 * \brief Computes the checksum on a buffer
 * \details No modification on buffer data is done
 * @param p_buffer: Pointer to buffer to check
 * @param v_len: Length of data to checksum
 * @return: checksum value (binary)
 */
INT8U f_UtilsL1ComputeChecksum(PINT8U p_buffer, INT8U v_len)
{
	INT8U v_chksum;
	INT8U v_idx;

	v_chksum = 0;

	for(v_idx=0; v_idx < v_len; v_idx++)
	{
		v_chksum += *(p_buffer+v_idx);
	}

	return v_chksum;
}

/*!
 * \brief In place put the L1 checksum on L1 message to Tx
 * \details Assumes that two chars are allocated before end of packet to place checksum
 * @param p_buffer: Complete L1 message to add checksum
 */
void f_UtilsL1TxPlaceChecksum(PINT8U p_buffer)
{
	INT8U v_idx;
	INT8U v_len;
	INT8U v_chksum;

	/* check that buffer starts with c_L1SOP char */
	if ( *p_buffer != c_L1SOP ) return;

	/* find length of packet, skip SOP */
	v_idx = 1;
	while(*(p_buffer+v_idx) != c_L1EOP )
	{
		v_idx++;
		/* Packet too long, do nothing */
		if (v_idx > 250) return;
	}
	/* length is decreased by SOP, EOP and Checksum chars */
	v_len = v_idx-1-2-1+1;

	/* if digits to replace are not "00", do not proceed further */
	if (*(p_buffer+v_idx-1) != '0') return;
	if (*(p_buffer+v_idx-2) != '0') return;

	/* compute checksum */
	v_chksum = f_UtilsL1ComputeChecksum(p_buffer+1, v_len);

	/* place checksum value */
	f_UtilsTypeConv_BinHex8(v_chksum, (PINT8) (p_buffer+1+v_len) );

}

/*!
 * \brief Check a given L1 packet for valid chars and Checksum
 * @param p_buffer: Pointer to L1 Packet
 * @return: eL1RxOk: for a Valid L1 packet, eL1RxChar: For invalid ASCII chars in L1 packet, eL1ChkSum: For Checksum error, eL1FrmErr: Bad format
 */
type_L1PacketCheck f_UtilsL1RxPacketCheck(PINT8U p_buffer)
{
	INT8U v_idx;
	INT8U v_len;
	INT8U v_chksum;
	INT8U v_chksumL1;
	INT8U v_ascii;

	/* check that buffer starts with c_L1SOP char */
	if ( *p_buffer != c_L1SOP ) return eL1FrmErr;

	/* find length of packet, skip SOP */
	v_idx = 1;
	while(*(p_buffer+v_idx) != c_L1EOP )
	{
		if (*(p_buffer+v_idx) == 0) return eL1FrmErr;
		v_idx++;
		/* Packet too long, do nothing */
		if (v_idx > 250) return eL1FrmErr;
	}

	v_len = v_idx;

	/* check ASCII Digits */
	v_ascii = f_UtilsGeneralASCIICheckOk(p_buffer, v_len);
	if (v_ascii == 0) return eL1RxChar;

	/* length is decreased by SOP, EOP and Checksum chars */
	v_len = v_idx-1-2-1+1;

	/* compute checksum */
	v_chksum = f_UtilsL1ComputeChecksum(p_buffer+1, v_len);
	v_chksumL1 = f_UtilsTypeConv_HexBin8(p_buffer+1+v_len);

	if (v_chksumL1 != v_chksum) return eL1ChkSum;

	return eL1RxOk;

}

/*!
 * \brief Convert INT8U to Hex string
 * \details A single binary INT8U data is converted to hex ascii (2-bytes) string
 * @param bin : Binary Byte to convert
 * @param str : String (2-byte) pointer to output
 */
void f_UtilsTypeConv_BinHex8(INT8U bin, INT8 *str)
{
	const INT8 lut_Hex[]={'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
	*(str+0) = lut_Hex[(bin >> 4) & 0x0f];
	*(str+1) = lut_Hex[bin & 0x0f];
}

/*!
 * \brief Convert INT16U to Hex string [4-bytes ASCII]
 * \warning Little Endian Implementation
 * @param v_bin : Binary 16-bit value to convert
 * @param str	: ASCII Hex string
 */
void f_UtilsTypeConv_BinHex16(INT16U v_bin, INT8 *str)
{
	INT8U v_byte;
	INT8 *p_mystr;

	p_mystr = str+2;
	v_byte = (INT8U) (v_bin & 0xff);
	f_UtilsTypeConv_BinHex8(v_byte, p_mystr);
	v_byte = (INT8U) ((v_bin >> 8) & 0xff);
	p_mystr = str;
	f_UtilsTypeConv_BinHex8(v_byte, p_mystr);
}




/*!
 * \brief Convert ASCII hex string (8-digits) to INT32U
 * @param hex	: Hex string 8-bytes long
 * @return		: INT32U value of hex string, or 0xFFFFFFFF in case of invalid hex digits
 *
 */
INT32U f_UtilsTypeConv_HexBin32(INT8U *hex)
{
	INT32U v_data;
	INT8U i;
	INT8U cbyte;

	v_data = 0L;

	for(i=0; i<8; i++)
	{
		cbyte = *(hex+i);

		/* do the conversion */
		if ( cbyte >= 'A') cbyte = (INT8U) ((cbyte - 'A') + 10);
		else cbyte-= '0';
		v_data |= (INT32U) (cbyte << (4*(7-i)));
	}

	return v_data;
}


/*!
 * \brief Convert ASCII hex string (4-digits) to INT16U
 * @param hex	: Hex string 4-bytes long
 * @return		: INT16U value of hex string, or 0xFFFF in case of invalid hex digits
 *
 */
INT16U f_UtilsTypeConv_HexBin16(INT8U *hex)
{
	INT16U data = 0;
	INT8U i;
	INT8U cbyte;


	for(i=0; i<4; i++)
	{
		cbyte = *(hex+i);
		if ( cbyte >= 'A') cbyte = (INT8U) ((cbyte - 'A') + 10);
		else cbyte-= '0';
		data |= (cbyte << (4*(3-i)));
	}

	return data;
}


/*!
 * \brief Convert ASCII hex string (2-digits) to INT8U
 * @param hex	: Hex string 2-bytes long
 * @return		: INT16U value of hex string, or 0xFF in case of invalid hex digits
 *
 */
INT8U f_UtilsTypeConv_HexBin8(INT8U *hex)
{
	INT8U data = 0;
	INT8U i;
	INT8U cbyte;


	for(i=0; i<2; i++)
	{
		cbyte = *(hex+i);

		if ( cbyte >= 'A') cbyte = (INT8U) ((cbyte - 'A') + 10);
		else cbyte-= '0';
		data |= (cbyte << (4*(1-i)));
	}

	return data;
}

/*!
 * \brief Copy RAM buffer to another RAM Buffer
 * @param p_src: Pointer to Source RAM location
 * @param p_dest: Pointer to Destination RAM location
 * @param v_len: Length of bytes to transfer
 */
void f_UtilsBufferCopyRam2Ram(PINT8U p_src, PINT8U p_dest, INT8U v_len)
{
	INT8U v_idx;

	for(v_idx=0; v_idx < v_len; v_idx++)
	{
		*(p_dest + v_idx) = *(p_src + v_idx);
	}

}

/*!
 * \brief Copy ROM buffer to RAM Buffer
 * @param p_src: Pointer to Source ROM location
 * @param p_dest: Pointer to Destination RAM location
 * @param v_len: Length of bytes to transfer
 */
void f_UtilsBufferCopyRom2Ram(const INT8U *p_src, PINT8U p_dest, INT8U v_len)
{
	INT8U v_idx;

	for(v_idx=0; v_idx < v_len; v_idx++)
	{
		*(p_dest + v_idx) = *(p_src + v_idx);
	}

}

INT8U f_UtilsFindL3CmdIdx(PINT16U p_lut, INT8U v_len, INT16U v_element)
{
	PINT16U p_start, p_stop, p_curr;
	INT16U v_curr;
	INT8U v_idx;

	p_start = p_lut;
	p_stop = p_lut + v_len - 1;

	/* make sure that first pass of the while loop will occur */
	v_curr = v_element+1;

	while(v_curr != v_element)
	{
		/* compute new binary index */
		v_idx = (INT8U) ( (p_stop - p_start) >> 1 );
		/* compute new binary pointer */
		p_curr = p_start + v_idx;
		/* get binary element */
		v_curr = *p_curr;

		/* check if we need to adjust ends */
		/* if data is matched then while will exit */
		if (v_element > v_curr) p_start = p_curr;
		if (v_element < v_curr) p_stop = p_curr;

		/* start and stop positions are side-by-side, nowhere else to search */
		if (p_start == (p_stop-1) )
		{
			/* check if needed element is the start point */
			v_curr = *p_start;
			if (v_element == v_curr)
			{
				p_curr = p_start;
				v_idx = 0;
			}
			else /* not found in start, assume the stop */
			{
				v_curr = *p_stop;
				p_curr = p_stop;
				v_idx = v_len - 1;
			} /* end of start/stop assignment */

			break;
		} /* end of neighborhood match search */

	} /* end of while search*/

	/* if there is no match return 0xFF (assuming LUT with less elements */
	if (v_curr == v_element) return v_idx;
	else return 0xFF;

}

/*!
 * \brief Copy a string to another buffer, with a maximum set length limit
 * @param p_src		: Pointer to Source data
 * @param p_dst		: Pointer to Destination Data
 * @param v_maxlen	: Maximum lenght of bytes to transfer if NULL character is not encountered
 * @return			: Count of actual characters copied
 */
INT8U f_UtilsCopyString(PINT8U p_src, PINT8U p_dst, INT8U v_maxlen)
{
	INT8U v_idx;
	INT8U v_cnt;

	v_cnt = 0;
	for(v_idx=0; v_idx<v_maxlen; v_idx++)
	{
		*p_dst = *(p_src+v_idx);
		v_cnt++;
		if ( *p_dst++ == 0) break;
	}

	return v_cnt;
}


/*!
 * \brief Compute String Length (counts up to 65535 or NULL)
 * @param p_src		: Pointer to Source data (Null Terminated String)
 * @return			: Length of string
 */
INT16U f_UtilsStrLen(PINT8U p_src)
{
	INT16U v_idx;
	INT16U v_cnt;

	v_cnt = 0;
	for(v_idx=0; v_idx<65535; v_idx++)
	{
		if ( *(p_src+v_idx) == 0) break;
		v_cnt++;
	}

	return v_cnt;
}


/*!
 * \brief Compare binary buffer of given length
 * @param p_str1 : Pointer to reference binary data set (word aligned)
 * @param p_str2 : Pointer to checking binary data set (word aligned)
 * @param v_len  : Length of buffer to compare
 * @return 0 for NULL pointers, No match, or zero-length data. 1 for comparison success.
 * \details Check for NULL pointers. In this case (at least one pointer is NULL) no comparison occurs
 */
INT8U f_UtilsCmpBuffer16(INT16U *p_str1, INT16U *p_str2, INT16U v_len)
{
	INT16U *p_srcstr;
	INT16U *p_dststr;
    INT16U v_idx;

	p_srcstr = p_str1;
	p_dststr = p_str2;

	/* If pointer empty then return */
	if (p_srcstr == NULL) return 0;
	if (p_dststr == NULL) return 0;

    v_idx = 0;

	for(v_idx=0; v_idx<v_len; v_idx++)
	{
		if ( *p_dststr != *p_srcstr) return 0;
		p_srcstr++;
		p_dststr++;
	}

    /* check for NULL string input */
    if (v_idx == 0) return 0;

    /* Else indeed strings are same */
	return 1;
}



/*!
 * \brief Compare binary buffer of given length, for equal, greater or less
 * @param p_str1 : Pointer to reference binary data set
 * @param p_str2 : Pointer to checking binary data set
 * @param v_len  : Length of buffer to compare
 * @return 255 for NULL pointers, 0=Equal, 1= Str1 Greater, 2: Str2 Greater
 * \details Check for NULL pointers. In this case (at least one pointer is NULL) no comparison occurs
 */
INT8U f_UtilsCmpBuffer8(INT8U *p_str1, INT8U *p_str2, INT16U v_len)
{
	INT8U *p_srcstr;
	INT8U *p_dststr;
    INT16U v_idx;
    INT8U v_retval;

	p_srcstr = p_str1;
	p_dststr = p_str2;

	v_retval = 0xFF;

	/* If pointer empty then return */
	if (p_srcstr == NULL) return v_retval;
	if (p_dststr == NULL) return v_retval;

    v_idx = 0;

	for(v_idx=0; v_idx<v_len; v_idx++)
	{
		if ( *p_srcstr > *p_dststr) return 1;
		if ( *p_srcstr < *p_dststr) return 2;
		p_srcstr++;
		p_dststr++;
	}

    /* Else indeed strings are same */
	return 0;
}

INT16 f_UtilsAbs(INT16 v_signed)
{
	INT16 v_retval;

	v_retval = v_signed;

	if (v_signed < 0) v_retval = -v_signed;

	return v_retval;
}

#ifdef c_UTEST_HOST

#endif


